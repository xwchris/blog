---
title: "CSS基础整理"
date: "2017-08-04"
tags: css
author: xwchris
desc: "读CSS权威指南记录下的知识点，待以后方便查阅，回忆，学习"
---

## CSS和文档
- 文档一定要有一个内部结构，而且这与视觉结构完全是两码事。页面应当博爱韩有某种结构含义的信息。
- 为了成功加载一个外部样式表，`link`必须放在`head`元素中，但不能放在其他元素内部。
- `link`属性中的`rel`代表关系，关系为`stylesheet`。type表示类型总是`text/css`。这个值描述了使用`link`标记加载的数据类型。`href`是样式表的URL。`media`属性使用`all`说明这个样式表要应用于所有的表现媒体
- `@import`用于指示Web浏览器加载一个外部样式表，并在表现HTML文档时使用样式。与`link`的区别是他必须放在`style`中，也就是要放在其他css规则之前，否则根本不起作用。
```
@import url(sheet.css);
```
## 选择器
- 简单属性选择器和具体属性选择器。简单属性选择器根据是否有该属性来选择某个元素。语法为`ele[attribute]`。具体属性选择器可以只选择有特定属性的元素。语法为`ele[class="value"]`
```
//简单属性选择器
h1[class] {color: silver;}
//具体属性选择器
h1[class="warning"] {color: silver}
```
- 根据部分属性选择。它可以匹配属性中的属性来选取元素。
```
p[class~="warning"] {font-weight: bold;}
```
这个例子可以匹配`<p class="urgent warning"></p>`,波浪号根据属性值中出现的一个用空格分割的词来完成原则。如果忽略该波浪号，就需要完成完全值匹配。
### 子串匹配属性选择器

类型 | 描述
---|---
[foo^="bar"] | 选择foo属性值以"bar"开头的所有元素
[foo$="bar" | 选择foo属性值以"bar"结尾的所有元素
[foo*="bar"] | 选择属性值中包含子串"bar"的所有元素
## 结构和层叠
- 当css声明冲突的时候，特殊性高的优先显示。特殊性有相应的规则和计算方法。内联样式比其他的声明都高。同时重要声明`!important`超过了超过了所有其他声明。该标志一般放在样式声明的最后。
- 继承。基于继承机制，样式不仅应用到指定的元素，还会应用到它的后代元素。样式会向下传递，绝不会向上传递，但有一个例外，在HTML中，对于向上传播规则有一个例外：应用到body元素的背景样式可以传递到html元素（html是文档的根元素），相应地可以定义其画布。有些属性是无法继承的比如边框和外边距，内边距。而且继承无特殊性，就是比0还要低。这也就解释了当设置`<a>`标签之外的父容器的字体颜色时，`<a>`标签的颜色不会变，这是因为用户代理的超链接占上风。
- CSS2.1层叠规则：
1. 找出所有相关的规则，这些规则都包含与一个既定元素匹配的选择器。
2. 读者的重要声明 > 创作人员的重要声明 > 创作人员的正常声明 > 读者的正常声明 > 用户的代理声明
3. 按特殊性给应用到的给定元素排序。有较高特殊性的元素权重要大于有较低特殊性的元素
4. 按出现顺序对应用到既定元素的所有声明排序。一个声明在样式表或文档中越后出现，它的权重就越大。如果样式表中有导入的样式表，一般认为出现在导入样式表中的声明在前，主样式表中所有声明在后。
- 由于顺序排序所以推荐的链接样式顺序为link-visited-hover-active(LVHA)的顺序声明链接样式。
## 值和单位
- Web安全颜色是指，在256色计算机系统上总能避免抖动的颜色，Web安全颜色的简写十六进制值是0,3,6,9,C和F；因此，`#693`、`#0C6`和`#F0F`都是Web安全颜色的例子。
- 长度单位分为绝对长度单位和相对长度单位，绝对长度单位有英寸(in)、厘米(cm)、毫米(mm)、点(pt)、排卡(pc)。相对单位有em, ex,px。常用的为相对单位，如果一个元素的`font-size`为14像素，那么对于该元素1em就等于14像素。px就是像素。常用的基本就是这两个。
- inherit。inherit关键字使一个属性的值与其父元素的值相同。在大多数的情况下，大多数属性会自然继承，不过在某些情况下还是很有用的。
- css2单位。角度值用于定义给定的声音从哪个位置发出。共有三种角度：度(deg)、梯度(grad)、和弧度(rad)。时间值秒(s)、毫秒(ms)。频率值赫兹(Hz)、或兆赫(MHz)。css2和css2.1规范都要求URI要以url(...)形式声明。
## 字体
- 建议在所有`font-family`规则中都提供一个通用字体系列。这样一来，就提供了一条后路，在用户代理无法提供与规则匹配的特定字体时，就可以选择一个候选字体。如果字体名称有空格则需求加入单引号，如`'New Century'`。
- `font-weight`取的值有

值 | 说明
---|---
normal | 标准粗细
bold | 粗体
bolder | 更粗的字体
lighter | 更细的字体
100，200，300，400，500，600，700，800，900 | 一般400为normal，700为bold，规则复杂 
- 字体大小继承继承的是计算后的大小而不是百分比。
- `font-style`的默认值是normal。`italic`是斜体,`oblique`是倾斜。
- `font-variant`用来提供字体变形，除了`normal`值可以使用`small-caps`来使用小型大写字母文本。这种效果如果单词是大写则会更大，如果单词问小写则变为大写。如果不存在则全部大写。
- `font`是所有字体元素属性的整合。font的前三个值为`font-style`、`font-weight`、`font-variant`的顺序可以随意，值为`normal`可以忽略，但是`font-size`和`font-family`必须为最后两个值，且他们必须存在，如果少了其中一期则整个规则都是无效的，很可能被用户代理完全忽略。同时`line-height`可以设置在`font`中作为对`font-size`的一个补充，并用一个斜线(/)与之分隔。
## 文本属性
- `text-indent`文本缩进，设置百分数设置的是父元素宽度的百分数。
- `text-align`的`justify`用来两端对齐。即每行文本的两端和父容器的左右边缘对齐。`middle`可以使文本居中它影响的只是内容并不会影响元素。同时`middle`可以使内联元素如`<a>`和`<img>`水平居中。
- `line-height`的`normal`值通常为字体大小的1.2倍，百分数是相对于字体大小来说的。当用em来设置`line-height`的时候可能会出现问题，因为子元素会从父元素继承，除了显示给每个子元素指定行高外还有一个更加简单的办法，那就是制定一个数，由它设置缩放因子。各个元素会根据自己的`font-size`计算`line-height`
- `vertical-align`属性不能继承。它作用于行内元素和替换元素。它不能影响块级元素中的内容对齐。由于该属性能够影响表单元格中元素的垂直对齐，所以可以利用让包含块`display:table-cell`结合`vertical-align:middle`来让图片垂直居中显示。[demo](http://www.zhangxinxu.com/study/201005/verticle-align-test-demo.html)

值 | 描述
---|---
top | 将元素行内框的顶端与包含该元素的行框的顶端对齐
bottom | 将元素行内框的底端与包含该元素的行框的底端对齐
text-top | 将元素行内框的顶端与父容器内容区的顶端对齐
text-bottom | 将元素行内框的底端与父容器内容区的底端对齐
middle | 将元素行内框的垂直中点与元素内容区的底端对齐
super | 将元素的内容区和行内框上移。上移的距离未指定，可能因用户代理的不同而不同。
sub | 与super相同，只不过元素会下移而不是上移
<percent> | 将元素上移或下移一定距离，这个距离由相对于元素`line-height`值指定一个百分比确定。

- `word-spacing`用来增加字之间的间隔。`letter-spacing`用来增加字母之间的间隔。他们默认为`normal`值就是0。`word-spacing`的值可能会受`text-align`属性值的影响。如果一个元素是两端对齐的，字母和字之间的空间可能会调整，以便文本在整行中正好放下。如果为`letter-spacing`指定一个长度值，字符间隔不会受`text-align`的影响，但是如果`letter-spacing`的值是`normal`那么字符间的间隔就可能改变，以便使文本两端对齐。CSS没有指定应当如何计算间隔，所以用户代理只是将其填满。一个元素的子元素会继承该元素的计算值。如果字母间隔与文本大小成比例，得到字母间隔的唯一办法就是显示地设置。
- `text-transform`用来进行文字转换`none`保持原状，`upppercase`全部大写`lowercase`全部小写`capitalize`只对每个单词的首字母大写。
- `text-decoration`默认为`none`,`underline`会对元素加下划线`overline`会加上划线,`line-through`会在文本中间画一条贯穿线。`blink`会让文本闪烁，该属性有的浏览器不支持。该属性不会被子元素继承，虽然看起来很怪，但这是创作人员希望的。
- `text-shadow`定义了文本的阴影效果，颜色可以写在后面或前面，其他三个值为向右偏移距离，向下偏移距离，模糊半径。这三个顺序不能乱。
- `white-space`属性

值 | 空白符 | 换行符 | 自动换行
---|---|---|---
pre-line | 合并 | 保留 | 允许
normal | 合并 | 忽略 | 允许
nowrap | 合并 | 忽略 | 不允许
pre | 保留 | 保留 | 不允许
pre-wrap | 保留 | 保留 | 允许
- `direction`和`unicode-bidi`不常用。
## 基本视觉格式化
- 内边距不能为负，而外边距可以。块级元素的宽度由左右外边距、左右内边距、边框宽度和内容宽度7个属性决定。
- 如果没有设置边框颜色，那么边框将使用前景色即`color`属性的颜色。
- 块级元素默认撑满容器，可以通过设置左右外边距来控制宽度。
- 将两个外边距设置为auto是将元素居中的一种正确方法，这不同于使用`text-align`(`text-align`只应用于块级元素的内联内容，所以将元素的`text-align`设置为`center`并不能将这个元素居中)
- 边框的宽度不能是百分数。
- 替换元素的所有规则都适用于非替换元素，只有一个例外：如果`width`为`auto`元素的宽度则是内容的固有宽度。如果元素的宽或高被更改，那么另一属性将成比例改变。
- 如果将一个元素的上、下外边距设置为`auto`，实际上他们都会充值为0，使元素框没有外边距。因此将元素垂直居中的唯一办法就是把上、下边距都设置为25%。不过这是在包含块的高度确定的情况下，如果没有显示声明包含块的高度，百分数高度会重置为`auto`。
- 如果块级正常流元素的高度设置为`auto`，并且只有块级子元素，其默认高度将是从最高块级子元素的外边框边界到最低块元素边框之间的距离。因此，子元素的外边距会超出包含这些元素的元素。但是如果包含元素设置了上边框或者下边框，上内边距或下内边距，其高度则是从最后子元素的上外边距边界到最低子元素的下外边距边界之间的距离。
- 垂直外边距合并。这种合并行为只会应用于外边距，如果元素有内边距和边框，它们绝不会合并。两个垂直外边距都为负则取其中绝对值较大的。如果是一个正一个负则会从正值中减去负值。
- 行内元素基本术语。
1. em框：em框在字体中定义，也称为字符框。实际的字形可能比其em框更高或更矮。在CSS中，`font-size`的值确定了各个em框的高度。
2. 内容区：在非替换元素中，内容区可能有两种，CSS2.1规范允许用户代理选择其中任意一种。内容区可以使元素中个字符的em框穿在一起构成的框，也可以是由元素中字符字形的框。在替换元素中，内容区就是元素的固有高度再加上可能有的外边距、边框或内边距。
3. 行间距：行间距是`font-size`值和`line-height`值只差。这个差实际上要分为两半，分别应用到内容区的顶部和底部。毫不奇怪，为内容区增加的这两部分分别称为半间距。行间距值应用于非替换元素。
4. 行内框：这个框通过向内容区增加行间距来描述。对于非替换元素，元素行内框的高度刚好等于`lin-height`的值。对于替换元素，元素行内框的高度则恰好等于内容区的高度，因为行间距不应用到替换元素。
5. 行框：这是包含该行中出现的行内框的最高点和最低点的最小框。换句话说，行内框的上边界要位于最高行内框的上边界，而行框的底边要放在最低行内框的下边界。
- CSS提供了一组行为和有用的概念。
1. 内容区类似于一个块级元素的内容框。
2. 行内元素的背景应用于内容区及所有内边距。
3. 行内元素的边框要包括内容区及所有内边距和边框。
4. 非替换元素的内边距、边框和外边距对行内元素或其生成的框没有垂直效果；也就是说，他们不会影响元素行内框的高度（也不会影响包含该元素的行框高度）。
5. 替换元素的外边距和边框确实会影响该元素行内框的高度，相应的，也可能影响包含该元素的行框高度。
- 行内元素的边框边界由`font-size`而不是`line-height`控制，换句话说，如果一个`span`元素的`font-size`为12px,`line-height`为36px,其内容区就是12px高，边框将包围该内容区。或者可以为行内元素指定内边距，这会把边框从文本本身拉开，这个内边框并没有改变内容区的具体形状，类似的向一个行内元素增加边框也不会影响行框的生成和布局。
- 实际上，外边距不会应用到行内非替换元素的顶端和底端，他们不影响行框的高度。不过，行内元素的两端则是另一回事。
- 行内替换元素。一般认为行内替换元素有固有高度。因此有固有高度的替换元素可能会导致行框比正常要高。这不会改变行中任何元素的`line-height`值，包括替换元素本身。换句话说，会用替换元素整体（包括内容、外边距、边框、和内边距属性）来定义元素的行内框。`line-height`对图像的行内框没有任何影响。行内替换元素能有`line-height`是为了在垂直对齐时能正确的对齐。
- 对于替换元素来说，内边距和边框确实会影响行框的高度，因为他们要作为行内替换元素的行内框的一部分（不同于行内非替换元素）。负外边距会师替换元素的行内框小于正常大小。负外边距会使替换元素的行内框小于正常大小。负外边距是使行内替换元素挤入其他行的唯一办法。
- 在行内块元素内部，会像块级元素一样设置内容的格式。就像所有块级或行内替换元素一样，行内块元素也有属性`width`和`height`，如果比周围内容高，这些属性会使行高增加。
- `display`的`run-in`。在css中不论元素是块元素还是行内元素都无关紧要，重要的是元素生成的框，而不是元素本身。设置`display:block`会生成一个块级框，设置`display:inline`则会生成一个行内框。如果一个元素生成`run-in`框，而且该框后面是一个块级框，那么该`run-in`元素将成为块级框开始处的一个行内框。
## 内边距、边框和外边距
- 外边距和内边距的百分数都是相对于父元素的`width`计算的。
- 值复制。CSS定义了一些规则，允许为外边距指定少于4个值。规则如下：
1. 如果缺少左外边距的值，则使用右外边距的值。
2. 如果缺少下外边距的值，则使用上外边距的值。
3. 如果缺少右外边距的值，则使用上外边距的值。
- `border-style`用于设置边框样式值有none,hidden,dotted,dashed,solid,double,groove,ridge,inset,outset。一般情况下hidden等价于none，不过应用于表时除外，对于表，hidden用于解决边框冲突。同时边框样式都可以单独设置。
- `border-width`用于设置边框宽度，它的值有thin,medium（默认）,thick。
## 颜色和背景
- `background-color`背景色默认为透明，所有背景属性都无法继承。
- `background-image`的值为url(图片地址)。
- `background-repeat`默认为平铺方式。它的值有repeat,repeat-x,repeat-y。
- `background-position`将相对于元素的内边距边界放置原图像。但有的浏览器会仙姑低于外边框边界而不是内边框边界来放置原图片。它的值有left,center,right,top,bottom或者百分数和数值。百分会让图片对应的与父容器的点对齐，如设置为50% 50%会让图像中心和元素中心对齐。
- 为了放置文档滚动的时候图片背景滚动可以使用`background-attachment`使用`fixed`值可以让背景保持不动，这样做的后果由两个一是原图像不会随文档滚动。其次，原图像的放置由可视区的大小确定而不是包含该图像的元素的大小（或在可视区中的位置）决定，而值如果是`scroll`则情况完全不同。值为`fixed`会使图像都从可视区左上角开始平铺而不是每个元素左上角，他们一样大只是他们都只在自己的区域可见，这就可以做出很有意思的[复螺旋变形](http://meyerweb.com/eric/css/edge/complexspiral/glassy.html)
- `background`可以简写这些属性，没有顺序限制，但是如果`background-position`有两个值，它们必须一起出现，而且如果这两个值是长度或百分数值，则必须按水平值在前垂直值在后的顺序。如果省略了某个属性会自动填入其他默认值。
## 浮动和定位
- 元素浮动的时候会以某种方式将浮动元素从文档的正常流中剔除，不过它还是会影响布局，它会使得其他内容环绕该元素。
- 浮动元素周围的外边距不会合并。浮动元素会自动生成一个块级框，不论这个元素本身是什么。
- 如果一个浮动元素在两个合并外间距之间，放置这个浮动元素时就好像在两个元素之间有一个块级父元素。另外浮动元素的顶端不能比之前所有浮动元素或块级元素的顶端更高。如果源文档中一个浮动元素之前出现另一个元素，浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高。这三条规则都是为了放置浮动元素一直浮动到父元素顶端。在其他规则下，浮动元素应尽可能高的放置，向左右浮动尽可能远。
- 当浮动元素与正常流元素重叠时：
1. 行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素“之上”显示。
2. 块框与一个浮动元素重叠时，其边框和背景在该浮动元素“之下”显示，而内容在浮动元素“之上”显示。
- `clear`清除浮动，放在要清除浮动的元素上面，不允许左边或右面出现浮动元素，它就会另起新的一行。
- `position`定位。`position`值的含义如下：
1. static：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。
2. `relative`：元素框偏移某个距离。元素扔保持未定位前的形状，它原本所占据的空间扔保留。
3. `absolute`元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是包含块。元素原先在正常文档流中所占的空间就会关闭，就好像该元素原来就不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。
4. `fixed`：元素框的表现类似于将`position`设置为`absolute`，不过其包含块是视窗本身。
如果是`abosolute`则其包含块设置为最近的`position`值不是`static`的祖先元素（可以是任何类型）,如果祖先为块级元素则设置包含块为该祖先元素的内边距。
- `top`和`bottom`偏移百分数是以包含块高度为基准的，`left`和`right`偏移百分数是以包含块宽度为基础的。偏移定位的是元素的外边距边界。
- 有时候通过使用`top`,`right`,`bottom`和`left`来描述元素四个边的放置位置，那么元素的高度和宽度将由这些偏移隐含确定。
- `overflow`的`visible`，`hidden`，`scroll`和`auto`其中`auto`是由用户代理来确定的。可以以配合`clip`来指定裁剪区域它的值有`rect(top,right,botton,left)`和`auto`。它不是相对于边偏移的是相对于父元素左上角偏移的。
- `visible`用来控制整个元素的可见性。`hidden`会使元素不可见但是仍然会影响文档布局，这与`display:none`是由区别的。`collapse`值在css表中显示使用。
- 绝对元素可以通过设置上下外边距设置为auto来实现垂直居中的行为。
```
<div style="position: relative; width: 10em; height: 10em; border:1px solid;">
    <div style="position: absolute; width: 100%; background: #CCC; top: 0; height: 5em; bottom;0 margin auto 0;"></div>
</div>
```
水平方向当然也是可以的，与竖直方向同理。
- 在水平布局中，如果值设置为`auto`，`right`或`left`都可以根据其静态位置放置。但在垂直布局中，只有`top`可以取静态位置，出于某种原因，`bottom`做不到。
- 利用`z-index`可以改变元素相互覆盖的顺序。元素的所有后代相对于该祖先元素都有其自己的叠放顺序。对于默认值`auto`规范有如下说明：当前得方上下文中生成框的栈层次与其父框的层次相同，这个框不会建立新的局部叠放上下文。所有可以将`auto`处理为`z-index:0`。在css2.1中规定元素绝对不会叠放在其叠放上下文的背景之下，也就说还在不能叠放在它的直接父亲下，但可以叠放在内容下。在mozila浏览器中会产生不一样的结果。所以`z-index`为负会导致不可预料的后果，小心使用。
- 在CSS中，内部元素表元素生成矩形框，这些框有内容、内边距和边框，但是没有外边距。即使指定了也会被忽略。
## 表布局
- `display`中的table相关值。

表元素 | 相应值
---|---
table | display:table
tr | display:table-row
thead | display:table-header-grounp
tbody | display:table-row-group
tfoot | display:table-footer-group
col | display:table-column
colgroup | display-column-group
td, td | display:table-cell
caption | display:table-caption
- 在CSS中列和列组只能接受四种样式：
1. border：只有当`border-collapse`属性值为`collapse`时才能为列和列组设置边框，在这种情况下，列和列组边框会参与设置各单元格边界边框样式的合并算法。
2. background：只有当单元格及其行有透明背景时，列或列组的背景才可见。
3. width：`width`属性定义了列或列组的最小宽度。列（或列组）中单元格的内容可能要求列更宽。
4. visibility：如果一个列或列组的`visibility`为`collapse`，则该列中所有单元格都不显示。从合并列跨到其他列的单元格会被裁剪，这类似于从其他列跨到隐藏列中的单元格。另外，表中总宽度会减去已合并列的宽度。如果对列 列组将`visibility`声明为任何非`collapse`值，则会被 
- CSS定义了机制，可以将“遗漏”的组件作为匿名对象插入。
- 为了完成显示，CSS定义了6个不同的层，可以分别放表的不同方面从下到上分别为表>列组>列>行组>行>单元格。
- `border-collapse`指定了两种模型一种为`collapse`合并边框模型，另一种为`separate`分隔单元格边框模型。
- `border-spacing`可以为单元格边框分隔一段距离。这是在分隔单元格模型下，否则会忽略该属性。
- 对于空单元格处理可以使用`empty-cells`设置为`show`会画出空单元格的边框和背景。如果为`hide`则不会画出该单元格的任何部分，就好像是`visibility: hidden`。如果这整行单元格都为空则处理完看起来像`display: none`。这是在分隔单元格模型下，否则会忽略该属性。
- 合并单元格模型使得单元格不能有任何内边距不过可以有内边距。极其复杂，暂忽略。
- 表的宽度由两种不同的方法：固定宽度布局和自动宽度布局。但不论使用哪种方法，高度都会自动计算。创作人员可以使用`table-layout`来选择采用哪种方法计算表的，二者之间最大的区别就是速度。使用固定宽度表布局时，相对于自动宽度模型，用户代理可以更快地计算出列的布局。
- 固定布局`fixed`。该布局是根据表以及表中列和单元格的`width`值决定的。确定宽度的步骤如下：
1. `width`属性值不是`auto`的所有列元素会根据`width`值设置该列的宽度。
2. 如果一个列的宽度为`auto`,不过，表首行中位于该列的单元格`width`不是`auto`则会根据该单元格宽度设置此列的宽度。如果这个单元格跨多列，则宽度在这些列上平均分配。
3. 在以上两步之后，如果列的宽度仍为`auto`会自动确定其大小，使其宽度尽可能相等。
此时，表设置为表的`width`或列宽度之和（取其中较大者）。如果表宽度大于其列宽总和，将二者之差除以列数，再把得到的这个宽度增加到每一列上。如果一个单元格的内容无法放下，该单元格的`overflow`值将决定单元格内容是裁剪、可见还是生成一个滚动条。
- 自动布局`auto`。该模型计算过程：
1. 用`width`和最小可能宽度进行比较，用较大的作为列的最小宽度，最大宽度为百分比或数值。
2. 最后跟表的宽度比较取较大的一个。
- 表的高度确定。最简单的直接由`height`属性显示设置高度。`height`看做表框的最下高度。
- 单元格中对齐非常容易。水平对齐使用`text-align:center`。垂直对齐使用`vertical-align:middle`。
## 列表与生成内容
- `list-style-type`用来修改列表项的标志类型。由于值太多这里就不列出。默认值为`disc`。该属性只能应用于`display`值为`list-item`的元素。该属性会继承如果不希望继承，可以显示声明。如果要使用图像作为列表项标志可以使用`list-style-image`。`list-style-position`用于设置标志项位置。默认为`outside`，也可以设置为`inside`。他们可以`list-style`简单写出，三个的顺序随意写出也都可以忽略。
- 生成内容。为了向文档中插入生成内容，可以使用`:before`和`:after` 伪元素。这些伪元素会根据`content`属性把生成内容放在一个内容前面或后面。同时。CSS2和CSS2.1明确地明确进制浮动或定位：`:before`和`:after`内容，还禁止使用样式列表属性以及表属性。另外还有以下限制：
1. 如果`:before`或`:after`选择器的主体是块级元素，则`display`属性只接受值`none`,`inline`,`block`和`marker`其他值都处理为`block`。
2. 如果`:before`或`:after`选择器的主体是行内元素，属性`display`只能接受值`none`和`inline`。所有其他值都处理为`inline`。另外生成元素会继承与之关联的元素的属性值。当然这种继承只适用于可继承属性。
- `content`属性除了串和uri还有许多其他的属性。串会原样显示，包括标签也会原样显示在里面。
- 有些情况下，要选取一个元素的属性值，使之作为文档显示的一部分。
```
a[href]:after {
    content: attr(href);
}
```
这也会导致生成内容与具体内容冲出的问题。为解决这个问题，可以向声明增加一些串值。
```
a[href]:after {
    content: "[" attr(href) "]";
}
```
- 生成内容有一种特殊形式，即引号。CSS2.x提供了`open-quote`等成对的`content`值以及属性`quotes`，使得生成引号的管理成为可能。可以用`content`的`open-quote`,`close-quote`,`no-open-quote`,`no-close-quote`来控制是否用引号。
- 计数器。创建计数器的基础包括两个方面，一个是设置计数器起点，二是能将其递增一定的量。设置起点由`counter-reset`处理
```
h1{ counter-reset: chapter 4; }
```
创建一个初始值为4的名为chapter的计数器。不写值则默认为0，`counter-increment`用来递增计数器，可以使负值，默认为1.
```
ol {
    counter-reset: ordered;
}/* defaults to 0 */

ol li {
    counter-increment: ordered;
}/* defaults to 1 */
```
要显示具体的数值还要配合`content`属性使用。
```
ol li:before{
    content: counter(ordered);
}
```
还可以为每个计数器定义一个样式列表，作为`counter()`格式的一部分。为此可以在计数器的标识符后面增加一个`list-style-type`关键字，用逗号分隔。
```
counter(ordered, uppper-alpha)
```
如果需要嵌套，就需要作用域的概念。简单的说，每层嵌套都会为给定计数器创建一个新的作用域。正是因为有作用域，以下规则才能以常规HTML方式实现嵌套表计数。
```
ol { counter-reset: ordered; }
ol li:before { counter-increment: ordered;
    content: counter(ordered) ". "}
```
这些规则会使有序列表（设置嵌套在其他）列表中的有序列表从1开始计数，并且逐项增1.一所以能做到，是每层嵌套都生成了一个新的order实例。
如果希望每层嵌套都创建一个新计数器追加到老计数器后面例如:1.1. 1.2. 1.3.就需要`counters`而不是`counter()`。可以使用`counters(ordered, ".")`来讲计数器串起来。
